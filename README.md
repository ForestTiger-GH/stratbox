# Strategy Box (stratbox)

## Назначение

`stratbox` — библиотека на Python, предназначенная для стандартизации типовых задач анализа данных и “прикладного IO” (чтение/запись файлов разных форматов) в Jupyter Notebook и в скриптах.

Библиотека создаётся как **единая “коробка инструментов”**: она даёт общий интерфейс и единый стиль для работы с файлами, чтобы прикладной код (аналитика, расчёты, отчёты) не разрастался “зоопарком” разрозненных функций и специфичных интеграций.

При этом `stratbox` сознательно остаётся **публикуемым и нейтральным**: в нём нет “внутренних” деталей конкретной инфраструктуры. Подключение корпоративных или внешних сервисов реализуется через механизм **провайдеров** и **плагинов** (см. ниже).

---

## Ключевые идеи

### 1) Единый IO API поверх FileStore

Рекомендуемый импорт:

```python
from stratbox.base import ioapi as ia
```

Далее код использует единый стиль:

- `ia.excel.read_df(...)`, `ia.excel.write_df(...)`
- `ia.csv.read_df(...)`, `ia.csv.write_df(...)`
- `ia.bytes.read_bytes(...)`, `ia.bytes.write_bytes(...)`
- и т.д.

Внутри эти операции выполняются **поверх FileStore** — абстракции “файлового пространства” (локального или внешнего).

### 2) FileStore: локально по умолчанию, расширяемо через провайдеры

`FileStore` — это интерфейс, который умеет:

- открыть файл на чтение/запись как поток (binary),
- прочитать/записать файл целиком (bytes),
- проверять существование, создавать каталоги и т.п.

В “чистой” установке `stratbox` использует **локальный** `LocalFileStore` (обычная файловая система).

Если установлен и активирован внешний провайдер, тот же код начинает работать с **другим хранилищем** (например, сетевым), без изменения прикладной логики.

### 3) SecretProvider: безопасная доставка параметров

Для интеграций и провайдеров часто нужны параметры подключения (логин, пароль, хост, share, токены и т.п.).  
`stratbox` закладывает принцип: **секреты не хранятся в коде** и не “зашиваются” в репозиторий.

За получение параметров отвечает `SecretProvider` (базовые реализации — из окружения и интерактивного ввода).

### 4) runtime: одна точка выбора режима (local / plugin)

Модуль `stratbox.base.runtime` решает:

- использовать ли провайдеры из плагина,
- или работать в локальном режиме.

Доменный/прикладной код не импортирует плагины напрямую.

---

## Что входит в библиотеку

Ниже перечислены основные модули `ioapi`. Все они работают поверх FileStore и предназначены для типовых задач аналитика.

### Табличные форматы

- **Excel**: `ia.excel`  
  Поддерживаются форматы `xlsx`, `xlsm`, `xlsb`, `xls` (набор зависит от доступных зависимостей).
- **CSV**: `ia.csv`  
  Чтение/запись `pandas.DataFrame`.
- **DBF**: `ia.dbf`  
  Чтение DBF в `pandas.DataFrame` (полезно для “наследных” выгрузок).

### Текстовые форматы и “сырые байты”

- **TXT**: `ia.txt` — быстрые операции со строками.
- **XML**: `ia.xml` — чтение/запись строк.
- **Bytes**: `ia.bytes` — универсальные `read_bytes` / `write_bytes` для любых бинарных файлов.

### Документы, презентации, изображения

- **DOCX**: `ia.docx` — извлечение текста, простая запись текста в DOCX.
- **PPTX**: `ia.pptx` — чтение/запись презентаций как bytes (или минимальные операции, если предусмотрены модулем).
- **Images**: `ia.images` — базовые операции с изображениями (если используются в окружении).

### Архивы

- **ZIP**: `ia.zip` — чтение/запись zip-архивов (bytes).
- **RAR**: `ia.rar` — чтение/распаковка RAR (при наличии внешнего инструментария, см. ниже).
- **Archives**: `ia.archives` — “обобщающие” операции с архивами.

---

## Установка

### Вариант A. Установка из PyPI (если доступно)

```bash
pip install stratbox
```

### Вариант B. Установка из репозитория (локально)

Из корня репозитория:

```bash
pip install -e .
```

> Режим `-e` удобен для разработки: изменения в коде применяются сразу, без переустановки.

---

## Быстрый старт (локальный режим)

### Пример 1. Excel (xlsx): запись и чтение DataFrame

```python
import pandas as pd
from stratbox.base import ioapi as ia

df = pd.DataFrame({"a": [1, 2], "b": [3, 4]})

ia.excel.write_df("out.xlsx", df)
df2 = ia.excel.read_df("out.xlsx")

print(df2.head())
```

### Пример 2. CSV

```python
import pandas as pd
from stratbox.base import ioapi as ia

df = pd.DataFrame({"x": [10, 20]})
ia.csv.write_df("data/out.csv", df)

df2 = ia.csv.read_df("data/out.csv")
print(df2)
```

### Пример 3. Сырые байты (любой формат)

```python
from stratbox.base.ioapi.bytes import write_bytes, read_bytes

write_bytes("bin/hello.bin", b"hello")
data = read_bytes("bin/hello.bin")
print(data)
```

---

## Работа через FileStore (единая логика путей)

Во многих средах удобнее мыслить “путями внутри хранилища”, а не абсолютными путями ОС.

При работе через `ioapi` путь трактуется как **путь внутри активного FileStore**.  
В локальном режиме это означает “относительно текущей директории/настроенного корня”, а при внешнем провайдере — “внутри внешнего хранилища”.

Пример прикладного кода, который не привязан к конкретной среде:

```python
from stratbox.base import ioapi as ia

df = ia.excel.read_df("reports/monthly/report.xlsx")
ia.csv.write_df("exports/report.csv", df)
```

---

## Переменные окружения (конфигурация поведения)

`stratbox` поддерживает несколько переменных окружения, которые помогают адаптировать работу под разные среды.

### STRATBOX_AUTO_PIP

- `STRATBOX_AUTO_PIP=0` (по умолчанию): если не хватает опциональной зависимости — будет понятная ошибка с подсказкой, что установить.
- `STRATBOX_AUTO_PIP=1`: при отсутствии зависимости `stratbox` попробует поставить пакет через `pip` автоматически.

Пример для Jupyter:

```python
import os
os.environ["STRATBOX_AUTO_PIP"] = "1"
```

> Важно: в ограниченных средах (без выхода в интернет) авто-установка может быть недоступна. Тогда рекомендуется заранее установить нужные пакеты “белым списком”.

### STRATBOX_USE_PLUGIN

- `STRATBOX_USE_PLUGIN=1`: принудительная попытка загрузить провайдеры из плагина.
- `STRATBOX_USE_PLUGIN=0`: принудительный локальный режим.

Если переменная не задана, `runtime` обычно пытается использовать плагин “если он установлен и доступен”.

### STRATBOX_DEBUG_PLUGIN

- `STRATBOX_DEBUG_PLUGIN=1`: при проблемах загрузки плагина включает подробный traceback (удобно для диагностики).

### STRATBOX_LOCAL_ROOT

В локальном режиме может использоваться как “корень” хранилища по умолчанию (если требуется закрепить базовую директорию хранения).

---

## Зависимости и совместимость

### Версия Python

Ориентир: **Python 3.10+** (точные ограничения фиксируются в `pyproject.toml`).

### Опциональные зависимости (по форматам)

Некоторые форматы требуют дополнительных пакетов. Логика следующая:

- по умолчанию — понятная ошибка с подсказкой `pip install ...`
- при `STRATBOX_AUTO_PIP=1` — попытка авто-установки

Часто встречающиеся зависимости:

- Excel `xlsx/xlsm`: `openpyxl`
- Excel `xls`: `xlrd` (чтение), `xlwt` (запись)
- Excel `xlsb`: `pyxlsb`
- RAR: `rarfile` (и внешний unrar/bsdtar в зависимости от ОС/окружения)
- DOCX: `python-docx`
- DBF: зависит от реализации модуля (обычно `dbfread`)

---

## Архитектура проекта (для разработчиков)

- `stratbox/base/runtime.py` — выбор провайдеров (local/plugin)
- `stratbox/base/filestore/` — интерфейс FileStore + локальная реализация
- `stratbox/base/secrets/` — базовые провайдеры секретов
- `stratbox/base/ioapi/` — форматные модули (excel/csv/xml/bytes/…)
- `stratbox/base/utils/` — инфраструктурные утилиты (например, optional deps)

---

## Рекомендации по использованию в Jupyter

1) Стараться фиксировать окружение (venv/conda) и явно ставить зависимости.
2) Если включается `STRATBOX_AUTO_PIP=1`, рекомендуется делать это осознанно (например, только в sandbox-среде).
3) При смене переменных окружения в Jupyter обычно нужен перезапуск kernel, чтобы поведение runtime было предсказуемым.

---

## Вклад в проект

Ожидаемый стиль изменений:

- небольшие, осмысленные PR;
- примеры использования (scripts/smoke или notebooks);
- ясные сообщения коммитов и краткое описание причин изменения;
- новые IO-модули — в едином стиле: `read_*` / `write_*`, читаемые ошибки, без лишнего вывода в stdout.

---

## Лицензирование

Файл лицензии и политика распространения определяются владельцами репозитория.  
При публикации в открытый доступ рекомендуется явно закрепить выбранную лицензию (например, MIT/Apache-2.0) и добавить `LICENSE`.
